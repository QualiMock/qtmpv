# QTMPV
Отрисовка элементов интерфейса происходит с помощью объектов С++ фреймворка **Qt** - `QWidget`. Получение сообщений происходит благодаря **Linux API**, используя модуль `sys/msg.h`.
### Получение сообщений от другого процесса
Получение сообщений, как ранее говорилось - происходит благодаря **Linux API** - модулю `sys/msg.h`. Получение сообщений происходит в бесконечном цикле функции `MainWindow::msgget_loop()`, где внешняя функция `msgrcv` является блокируещей. Та в свою очередь принимает **ID**, которое генерируется с помощью функций `ftok`, которая в свою очередь генерирует ключ с помощью файла по пути `/etc/qtmpv/token.txt`, который в свою генерируется благодаря установщику `installer.bash`. В директории `child` данного репозитория находится простой пример на **C**, который генерирует случайные числа и отсылает их с помощью `msgsnd` в бесконечном цикле.
### Отрисовка элементов интерфейса
Для лучшей оптимизации создается процесс `ffplay` с разраешением *1920х1080* пикселей и *24* к/с. Далее с помощью **X11 API** вычисляются координаты и размеры окна процесса `ffplay`. `XOpenDisplay(NULL)` подключается к серверу **X11**, далее в функции `MainWindow::find_windows(Display *display, ulong *winCount)` мы получаем список всех открытых окон, далее пробегаясь по полученному списку мы узнаем **PID** каждого окна и сверяем его с ранее полученым **PID** `ffplay` процесса. Далее с помощью функции `XTranslateCoordinates` передаем в структуру `attrs` класса `MainWindow` координаты и размеры нужного нам окна и далее проверям на изменение эти данные. Если изменения произошли, то мы удаляем виджеты и снова отрисовываем их, для того, чтобы *они были отрисованы поверх окна `ffplay`*. Так же в функции `MainWindow::msgget_loop()` происходит изменение цвета в виджете `overlayLine`.
### Установка
Установка происходит всего-лишь с помощью установщика:
```bash
sudo bash installer.bash
```

